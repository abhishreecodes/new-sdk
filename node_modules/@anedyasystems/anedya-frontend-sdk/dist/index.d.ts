interface INewConfig {
    tokenId: string;
    token: string;
    baseUrl: string;
}
declare class NewConfig implements INewConfig {
    tokenId: string;
    token: string;
    baseUrl: string;
    constructor(tokenId: string, token: string);
}

interface IClient {
    tokenId: string;
    tokenBytes: Uint8Array;
    signatureVersionBytes: Uint8Array;
    signatureVersion: string;
    authorizationMode: string;
    baseUrl: string;
}
/**
 * Class representing a anedya client with configuration details.
 */
declare class NewClient implements IClient {
    tokenId: string;
    tokenBytes: Uint8Array;
    signatureVersionBytes: Uint8Array;
    signatureVersion: string;
    authorizationMode: string;
    baseUrl: string;
    /**
     * Constructs a new instance of NewClient.
     * @param {NewConfig} config - The configuration object.
     */
    constructor(config: NewConfig);
}

interface _ITimeSeriesData {
    [key: string]: object[];
}
interface _IError {
    errorMessage: string;
    reasonCode: string;
}

interface IAnedyaGetDataReq {
    variable: string;
    from: number;
    to: number;
    limit: number;
    order: "asc" | "desc";
}
/**
 * Request object for fetching data.
 */
declare class AnedyaGetDataReq implements IAnedyaGetDataReq {
    variable: string;
    from: number;
    to: number;
    limit: number;
    order: "asc" | "desc";
    constructor(variable: string, from: number, to: number, limit?: number, order?: "asc" | "desc");
}
interface IAnedyaGetDataResp {
    isSuccess: boolean;
    error: _IError;
    isDataAvailable: boolean;
    data: _ITimeSeriesData | null;
    count: number;
    startTime: number;
    endTime: number;
}
/**
 * Response object for fetching data.
 */
declare class AnedyaGetDataResp implements IAnedyaGetDataResp {
    isSuccess: boolean;
    error: _IError;
    isDataAvailable: boolean;
    data: _ITimeSeriesData | null;
    count: number;
    startTime: number;
    endTime: number;
    constructor();
}
interface IAnedyaGetLatestDataResp {
    isSuccess?: boolean;
    error: _IError;
    isDataAvailable?: boolean;
    data?: _ITimeSeriesData | null;
}
declare class AnedyaGetLatestDataResp implements IAnedyaGetLatestDataResp {
    isSuccess?: boolean;
    error: _IError;
    isDataAvailable?: boolean;
    data?: _ITimeSeriesData | null;
    constructor();
}
interface IAnedyaSetKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
    value: string | number | boolean;
    type: "string" | "binary" | "float" | "boolean";
}
declare class AnedyaSetKeyReq implements IAnedyaSetKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
    value: string | number | boolean;
    type: "string" | "binary" | "float" | "boolean";
    constructor(namespace: {
        scope: "global" | "node";
        id?: string;
    }, key: string, value: string | number | boolean, type: "string" | "binary" | "float" | "boolean");
}
interface IAnedyaSetKeyResp {
    isSuccess: boolean;
    error: _IError;
}
declare class AnedyaSetKeyResp implements IAnedyaSetKeyResp {
    isSuccess: boolean;
    error: _IError;
    constructor();
}
interface IAnedyaGetKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
}
declare class AnedyaGetKeyReq implements IAnedyaGetKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
    constructor(namespace: {
        scope: "global" | "node";
        id?: string;
    }, key: string);
}
interface IAnedyaGetKeyResp {
    isSuccess: boolean;
    error: _IError;
    namespace: {
        scope: string;
        id: string;
    };
    key: string;
    value: string | number | boolean;
    type: string;
    size: number;
    modified: number;
    created: number;
}
declare class AnedyaGetKeyResp implements IAnedyaGetKeyResp {
    isSuccess: boolean;
    error: _IError;
    namespace: {
        scope: string;
        id: string;
    };
    key: string;
    value: string | number | boolean | any;
    type: string;
    size: number;
    modified: number;
    created: number;
    constructor();
}
interface IAnedyaDeleteKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
}
declare class AnedyaDeleteKeyReq implements IAnedyaDeleteKeyReq {
    namespace: {
        scope: "global" | "node";
        id?: string;
    };
    key: string;
    constructor(namespace: {
        scope: "global" | "node";
        id?: string;
    }, key: string);
}
interface IAnedyaDeleteKeyResp {
    isSuccess: boolean;
    error: _IError;
}
declare class AnedyaDeleteKeyResp implements IAnedyaDeleteKeyResp {
    isSuccess: boolean;
    error: _IError;
    constructor();
}
interface IAnedyaScanKeysReq {
    filter: {
        namespace: {
            scope: "global" | "node";
            id?: string;
        };
    };
    orderby: "namespace" | "key" | "created";
    order: "asc" | "desc";
    limit: number;
    offset: number;
}
declare class AnedyaScanKeysReq implements IAnedyaScanKeysReq {
    filter: {
        namespace: {
            scope: "global" | "node";
            id?: string;
        };
    };
    orderby: "namespace" | "key" | "created";
    order: "asc" | "desc";
    limit: number;
    offset: number;
    constructor(filter: {
        namespace: {
            scope: "global" | "node";
            id?: string;
        };
    }, orderby: "namespace" | "key" | "created", order: "asc" | "desc", limit: number, offset: number);
}
interface IAnedyaScanKeysResp {
    isSuccess: boolean;
    error: _IError;
    count: number;
    totalCount: number;
    data: any;
    next: number;
}
declare class AnedyaScanKeysResp implements IAnedyaScanKeysResp {
    isSuccess: boolean;
    error: _IError;
    count: number;
    totalCount: number;
    data: any;
    next: number;
    constructor();
}
interface IAnedyaGetDeviceStatusResp {
    isSuccess: boolean;
    error: _IError;
    data: any;
}
declare class AnedyaGetDeviceStatusResp implements IAnedyaGetDeviceStatusResp {
    isSuccess: boolean;
    error: _IError;
    data: any;
    constructor();
}
interface IAnedyaGetSnapshotReq {
    time: number;
    variable: string;
}
declare class AnedyaGetSnapshotReq implements IAnedyaGetSnapshotReq {
    time: number;
    variable: string;
    constructor(time: number, variable: string);
}
interface NodeVariableValue {
    node: string;
    value: number | string | boolean | Uint8Array;
    timestamp: number;
}
type NodeVariableValues = NodeVariableValue[];
interface IAnedyaGetSnapshotResp {
    isSuccess: boolean;
    error: _IError;
    count: number;
    data: NodeVariableValues;
}
declare class AnedyaGetSnapshotResp implements IAnedyaGetSnapshotResp {
    isSuccess: boolean;
    error: _IError;
    count: number;
    data: NodeVariableValues;
    constructor();
}

/**
 * INode defines the contract for interacting with a node in Anedya.
 * Each method corresponds to an available operation on a node.
 */
interface INode {
    /** Returns the unique identifier of this node */
    getNodeId(): string;
    /** Fetch historical time-series data for a given variable */
    getData(accessDataReq: IAnedyaGetDataReq): Promise<any>;
    /** Fetch the most recent data point for a given variable */
    getLatestData(variableIdentifier: string): Promise<any>;
    /** Store a key-value pair in the node’s value store */
    setKey(reqConfig: AnedyaSetKeyReq): Promise<any>;
    /** Retrieve a value from the node’s value store */
    getKey(reqConfig: IAnedyaGetKeyReq): Promise<any>;
    /** Delete a value from the node’s value store */
    deleteKey(reqConfig: IAnedyaDeleteKeyReq): Promise<any>;
    /** Scan through the node’s value store with filters */
    scanKeys(reqConfig: IAnedyaScanKeysReq): Promise<any>;
    /** Get device status (e.g., last contact timestamp) */
    getDeviceStatus(lastContactThreshold: number): Promise<any>;
    /**
     * Returns value of a variable at a particular time for given set of nodes.
     * Returns nearest datapoint submitted before specified time incase no datapoints found at the exact timestamp.
     */
    getSnapshot(reqConfig: IAnedyaGetSnapshotReq): Promise<any>;
}
/**
 * NewNode represents a Node in the Anedya platform and is a concrete implementation of INode.
 *
 *
 * A Node is the primary abstraction for interacting with data and value stores
 * belonging to a specific device. This class handles authentication, signing,
 * and structured request/response handling for Node operations.
 */
declare class NewNode implements INode {
    #private;
    /**
     * Construct a new Node instance.
     *
     * @param client - The initialized Anedya client with configuration details.
     * @param nodeId - Unique identifier of the node to interact with.
     */
    constructor(client: NewClient, nodeId: string);
    /**
     * Returns the Node ID.
     *
     * @returns {string} The node ID associated with this instance.
     *
     * @example
     * ```ts
     * console.log(node.getNodeId()); // "device123"
     * ```
     */
    getNodeId(): string;
    /**
     * Fetches time-series data from the node within the given time range.
     *
     * @param {Object} accessDataReq - The request object for fetching data.
     * @param {string} accessDataReq.variable - The variable identifier to fetch data for.
     * @param {number} accessDataReq.from - The start timestamp (in ms) of the query range.
     * @param {number} accessDataReq.to - The end timestamp (in ms) of the query range.
     * @param {number} [accessDataReq.limit=10000] - The maximum number of data points to return.
     * @param {"asc"|"desc"} [accessDataReq.order="desc"] - The order of the data points to return.
     * @returns {Promise<any>} A promise resolving to the response with data availability and payload.
     *
     * @example
     * ```ts
     * const req = new AnedyaGetDataReq("temperature", Date.now() - 86400000, Date.now(), 100);
     * const res = await node.getData(req);
     * if (res.isSuccess && res.isDataAvailable) {
     *   console.log(res.data);
     * }
     * ```
     */
    getData(accessDataReq: IAnedyaGetDataReq): Promise<any>;
    /**
     * Fetches the latest data point from the node for the given variable.
     *
     * @param {string} variableIdentifier - The variable identifier to fetch the latest data point for.
     * @returns {Promise<any>} A promise resolving to the response with data availability and payload.
     *
     * @example
     * ```ts
     * const res = await node.getLatestData("temperature");
     * if (res.isSuccess && res.isDataAvailable) {
     *   console.log("Latest value:", res.data);
     * }
     * ```
     */
    getLatestData(variableIdentifier: string): Promise<any>;
    /**
     * Sets a key/value pair in the Node's value store.
     *
     * This allows you to persist configuration or metadata at either the
     * `GLOBAL` or `NODE` scope.
     *
     * - `AnedyaScope.GLOBAL`: The key/value is available across all nodes in the account.
     * - `AnedyaScope.NODE`: The key/value is local to this specific node.
     *
     * Supported data types (via {@link AnedyaDataType}):
     * - `STRING` → Stores string values
     * - `BINARY` → Stores binary blobs
     * - `FLOAT` → Stores numeric values with decimals
     * - `BOOLEAN` → Stores true/false flags
     *
     * @param {AnedyaSetKeyRequestInterface} reqConfig - Request config including scope, key name, value, and type.
     * @returns {Promise<any>} Response indicating success/failure of the operation.
     *
     * @example
     * ```ts
     * // Store a floating-point threshold value for a node
     * const req = new AnedyaSetKeyReq(
     *   { scope: AnedyaScope.NODE },   // Limit to this node
     *   "temperature",                 // Key name
     *   30,                            // Value
     *   AnedyaDataType.FLOAT           // Data type
     * );
     *
     * const res = await node.setKey(req);
     * if (res.isSuccess) {
     *   console.log("Key set successfully!");
     * }
     * ```
     */
    setKey(reqConfig: AnedyaSetKeyReq): Promise<any>;
    /**
     * Retrieves a previously stored value for a key from the Node's value store.
     *
     * Scope determines where the SDK looks for the key:
     * - `AnedyaScope.GLOBAL`: Searches in the global store (shared across all nodes).
     * - `AnedyaScope.NODE`: Searches in this node’s local store only.
     *
     * @param {AnedyaGetKeyReqInterface} reqConfig - Config with scope and key name to fetch.
     * @returns {Promise<any>} Response containing the value if the key exists.
     *
     * @example
     * ```ts
     * // Fetch a temperature threshold key stored on this node
     * const req = new AnedyaGetKeyReq(
     *   { scope: AnedyaScope.NODE },
     *   "temperature"
     * );
     *
     * const res = await node.getKey(req);
     * if (res.isSuccess && res.data) {
     *   console.log("Key value:", res.data);
     * }
     * ```
     */
    getKey(reqConfig: IAnedyaGetKeyReq): Promise<any>;
    /**
     * Deletes a key/value pair from the Node's value store.
     *
     * Scope must match the scope in which the key was originally set:
     * - `AnedyaScope.GLOBAL`: Removes the key from the global store.
     * - `AnedyaScope.NODE`: Removes the key only from this node’s local store.
     *
     * @param {IAnedyaDeleteKeyReq} reqConfig - Config with scope and key name to delete.
     * @returns {Promise<any>} Response indicating whether deletion succeeded.
     *
     * @example
     * ```ts
     * // Remove a temperature threshold key stored on this node
     * const req = new AnedyaDeleteKeyReq(
     *   { scope: AnedyaScope.NODE },
     *   "temperature"
     * );
     *
     * const res = await node.deleteKey(req);
     * if (res.isSuccess) {
     *   console.log("Key deleted successfully!");
     * }
     * ```
     */
    deleteKey(reqConfig: IAnedyaDeleteKeyReq): Promise<any>;
    /**
     * Scans available items in the valuestore in a given namespace, with support for pagination. Can return max 100 items per call.
     *
     *
     * - Namespace must include a scope (`GLOBAL` or `NODE`).
     * - Results can be ordered (`asc` or `desc`) and paginated using limit/offset.
     *
     * @param {AnedyaScanKeysReqInterface} reqConfig - Config including namespace, order, limit, and offset.
     * @returns {Promise<any>} Response containing a list of matching keys.
     *
     * @example
     * ```ts
     * // Scan all available keys in the NODE namespace, return first 10 in ascending order
     * const req = new AnedyaScanKeysReq(
     *   { namespace: { scope: AnedyaScope.NODE } },
     *   "namespace",
     *   "asc",
     *   10,
     *   0
     * );
     *
     * const res = await node.scanKeys(req);
     * if (res.isSuccess && res.data) {
     *   console.log("Keys scanned successfully!", res.data);
     * }
     * ```
     */
    scanKeys(reqConfig: IAnedyaScanKeysReq): Promise<any>;
    /**
     * Checks whether this node is currently online by evaluating its last heartbeat timestamp.
     *
     * The Anedya platform stores the last heartbeat time for each device.
     * By passing `lastContactThreshold` (in seconds), you define how far back
     * the system should look for a heartbeat to consider the device online.
     *
     * - If the last heartbeat occurred within the past `lastContactThreshold` seconds → `online: true`
     * - Otherwise → `online: false`
     *
     * @param {number} lastContactThreshold - The number of past seconds in which the device must have
     *   sent a heartbeat to be considered online. For example, if set to `60`, the node is only online
     *   if its last heartbeat was within the last 60 seconds.
     *
     * @returns {Promise<any>} A promise resolving to the response object containing:
     * - `online` (boolean): whether the node is online
     * - `lastHeartbeat` (number): the last heartbeat timestamp (UNIX seconds)
     *
     * @example
     * ```ts
     * // Consider node online if it sent a heartbeat within the last 60 seconds
     * const res = await node.getDeviceStatus(60);
     * if (res.isSuccess && res.data) {
     *   const status = res.data[node.getNodeId()];
     *   console.log("Online:", status.online);
     *   console.log("Last heartbeat at:", new Date(status.lastHeartbeat * 1000));
     * }
     * ```
     *
     * @example
     * ```ts
     * // Use a larger window (300 seconds) if your device reports less frequently
     * const res = await node.getDeviceStatus(300);
     * ```
     */
    getDeviceStatus(lastContactThreshold: number): Promise<any>;
    /**
     * Retrieves the value of a variable for one or more nodes at a specific timestamp.
     *
     * The snapshot API returns the value of a variable at the requested time.
     * - If a datapoint exists at exactly that timestamp, it is returned.
     * - If no datapoint exists at that exact time, the nearest datapoint submitted
     *   before the specified time will be returned instead.
     *
     * This is useful for reconstructing system state at a given point in time
     * (e.g., "What was the temperature at 10:00 AM for node X?").
     *
     * @param {IAnedyaGetSnapshotReq} reqConfig - The snapshot request configuration.
     * @param {number} reqConfig.time - The target timestamp (in UNIX seconds) to query.
     * @param {string} reqConfig.variable - The variable identifier to fetch (e.g., `"temperature"`).
     *
     * @returns {Promise<any>} A promise resolving to the response object containing:
     * - `node` (string): the node ID
     * - `value` (number): the variable value at or before the given timestamp
     * - `timestamp` (number): the timestamp (UNIX seconds) of the returned datapoint
     *
     * @example
     * ```ts
     * // Get temperature value for node at a specific timestamp
     * const req = new AnedyaGetSnapshotReq(<timestamp>, <variableid>);
     * const res = await node.getSnapshot(req);
     * if (res.isSuccess && res.data.length > 0) {
     *   const snapshot = res.data[0];
     *   console.log("Temperature at", new Date(snapshot.timestamp * 1000), "was", snapshot.value);
     * }
     * ```
     *
     * @example
     * ```ts
     * // Request snapshots for multiple nodes at the same time
     * const req = new AnedyaGetSnapshotReq(1695084912, "humidity", ["node123", "node456"]);
     * const res = await node.getSnapshot(req);
     * res.data.forEach((entry) => {
     *   console.log(entry.node, "had humidity", entry.value, "at", new Date(entry.timestamp * 1000));
     * });
     * ```
     */
    getSnapshot(reqConfig: IAnedyaGetSnapshotReq): Promise<any>;
}

/**
 * This file contains main entry class for the Anedya SDK.
 *
 * @packageDocumentation
 */

interface IAnedya {
    NewConfig(tokenId: string, token: string): NewConfig;
    NewClient(configData: NewConfig): NewClient;
    NewNode(client: NewClient, nodeId: string): NewNode;
}
declare class Anedya implements IAnedya {
    NewConfig(tokenId: string, token: string): NewConfig;
    NewClient(configData: NewConfig): NewClient;
    NewNode(client: NewClient, nodeId: string): NewNode;
}

declare enum AnedyaScope {
    GLOBAL = "global",
    NODE = "node"
}
declare enum AnedyaDataType {
    STRING = "string",
    BINARY = "binary",
    FLOAT = "float",
    BOOLEAN = "boolean"
}

declare const AnedyaError: {
    readonly Success: -1;
    readonly Unknown: 0;
    readonly Failure: 1;
    readonly HttpRequestError: 3;
    readonly HttpRequestTimeout: 4;
    readonly keyNotFound: 5;
};

declare function getAnedyaErrorMessage(code: number): string;

export { Anedya, AnedyaDataType, AnedyaDeleteKeyReq, AnedyaDeleteKeyResp, AnedyaError, AnedyaGetDataReq, AnedyaGetDataResp, AnedyaGetDeviceStatusResp, AnedyaGetKeyReq, AnedyaGetKeyResp, AnedyaGetLatestDataResp, AnedyaGetSnapshotReq, AnedyaGetSnapshotResp, AnedyaScanKeysReq, AnedyaScanKeysResp, AnedyaScope, AnedyaSetKeyReq, AnedyaSetKeyResp, type IAnedyaDeleteKeyResp, type IAnedyaGetDeviceStatusResp, type IAnedyaGetKeyResp, type IAnedyaScanKeysResp, type IAnedyaSetKeyResp, getAnedyaErrorMessage };
