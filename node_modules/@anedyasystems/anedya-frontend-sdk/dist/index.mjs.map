{"version":3,"sources":["../src/config.ts","../src/client.ts","../src/models.ts","../src/anedya_signature.ts","../src/services/accessData.ts","../src/services/valueStore.ts","../src/services/deviceStatus.ts","../src/services/snapShot.ts","../src/node.ts","../src/anedya.ts","../src/anedya_constant.ts","../src/errors.ts","../src/utility.ts"],"names":["NewConfig","tokenId","token","NewClient","config","AnedyaGetDataReq","variable","from","to","limit","order","AnedyaGetDataResp","AnedyaGetLatestDataResp","AnedyaSetKeyReq","namespace","key","value","type","AnedyaSetKeyResp","AnedyaGetKeyReq","AnedyaGetKeyResp","AnedyaDeleteKeyReq","AnedyaDeleteKeyResp","AnedyaScanKeysReq","filter","orderby","offset","AnedyaScanKeysResp","AnedyaGetDeviceStatusResp","AnedyaGetSnapshotReq","time","currentUnixTime","AnedyaGetSnapshotResp","anedyaSignature","requestData","configHeaders","currentTime","bodyBytes","bodyHashBuffer","bodyHashBytes","timeBytes","combinedBytes","combinedHashBuffer","b","e","getData","baseUrl","nodes","accessDataReq","url","combinedHash","reqHeaders","response","res","responseData","data","error","fetchLatestData","setKey","reqConfig","Id","getKey","deleteKey","scanKeys","getDeviceStatus","lastContactThreshold","getSnapshot","getSnapshotReq","item","NewNode","#nodeId","#baseUrl","#configHeaders","client","nodeId","tokenBytes","signatureVersionBytes","signatureVersion","authorizationMode","variableIdentifier","Anedya","configData","AnedyaScope","AnedyaDataType","AnedyaError","getAnedyaErrorMessage","code","k","v"],"mappings":"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","file":"index.mjs","sourcesContent":["/*\n * This file contains the configuration details for the Anedya client.\n * It exports an interface (INewConfig) and a class (NewConfig) that are used\n * to represent the configuration data.\n */\nexport interface INewConfig {\n  tokenId: string;\n  token: string;\n  baseUrl: string;\n}\n\nexport class NewConfig implements INewConfig {\n  tokenId: string;\n  token: string;\n  baseUrl: string;\n\n  constructor(tokenId: string, token: string) {\n    if (!tokenId || tokenId.trim() === \"\") {\n      throw new Error(\"Token ID is required\");\n    }\n    if (!token || token.trim() === \"\") {\n      throw new Error(\"Token is required\");\n    }\n    this.tokenId = tokenId;\n    this.token = token;\n    this.baseUrl = \"https://api.anedya.io/v1\";\n  }\n}\n","/*\nFile contains the class NewClient which is used to create an instance of a anedya client.\n*/\nimport { NewConfig } from \"./config\";\n\nexport interface IClient {\n  tokenId: string;\n  tokenBytes: Uint8Array;\n  signatureVersionBytes: Uint8Array;\n  signatureVersion: string;\n  authorizationMode: string;\n  baseUrl: string;\n}\n\n/**\n * Class representing a anedya client with configuration details.\n */\nexport class NewClient implements IClient {\n  tokenId: string;\n  tokenBytes: Uint8Array;\n  signatureVersionBytes: Uint8Array;\n  signatureVersion: string = \"v1\";\n  authorizationMode: string = \"ANEDYASIGV1\";\n  baseUrl: string;\n\n  /**\n   * Constructs a new instance of NewClient.\n   * @param {NewConfig} config - The configuration object.\n   */\n  constructor(config: NewConfig) {\n    const { token, tokenId } = config;\n    this.tokenId = tokenId;\n    this.signatureVersionBytes = new TextEncoder().encode(\n      this.signatureVersion\n    );\n    this.tokenBytes = new TextEncoder().encode(token);\n    this.baseUrl = config.baseUrl;\n  }\n}\n","/*\n * This file contains the models for the Anedya SDK.\n * It exports interfaces and classes that are used to represent the data\n * and requests for the Anedya API.\n *\n */\nimport { _ITimeSeriesData, _IError } from \"./common\";\n\n// ============================== Data Access ==============================\n// ------------ Get Data ------------\nexport interface IAnedyaGetDataReq {\n  variable: string;\n  from: number;\n  to: number;\n  limit: number;\n  order: \"asc\" | \"desc\";\n}\n/**\n * Request object for fetching data.\n */\nexport class AnedyaGetDataReq implements IAnedyaGetDataReq {\n  constructor(\n    public variable: string,\n    public from: number,\n    public to: number,\n    public limit: number = 10000,\n    public order: \"asc\" | \"desc\" = \"desc\"\n  ) {\n    if (order !== \"asc\" && order !== \"desc\") {\n      throw new Error(\n        \"Invalid order value. It should be either 'asc' or 'desc'.\"\n      );\n    }\n    if (limit < 1) {\n      throw new Error(\"Invalid limit value. It should be at least 1.\");\n    }\n    if (from > to) {\n      throw new Error(\n        \"Invalid time range. 'from' should be less than or equal to 'to'.\"\n      );\n    }\n  }\n}\n\nexport interface IAnedyaGetDataResp {\n  isSuccess: boolean;\n  error: _IError;\n  isDataAvailable: boolean;\n  data: _ITimeSeriesData | null;\n  count: number;\n  startTime: number;\n  endTime: number;\n}\n/**\n * Response object for fetching data.\n */\nexport class AnedyaGetDataResp\n  implements IAnedyaGetDataResp\n{\n  isSuccess: boolean;\n  error: _IError;\n  isDataAvailable: boolean;\n  data: _ITimeSeriesData | null;\n  count: number;\n  startTime: number;\n  endTime: number;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.isDataAvailable = false;\n    this.data = null;\n    this.count = 0;\n    this.startTime = 0;\n    this.endTime = 0;\n  }\n}\n\n// ----------------------------- Get Latest Data -------------------------------------------\nexport interface IAnedyaGetLatestDataResp {\n  isSuccess?: boolean;\n  error: _IError;\n  isDataAvailable?: boolean;\n  data?: _ITimeSeriesData | null;\n}\n\nexport class AnedyaGetLatestDataResp implements IAnedyaGetLatestDataResp {\n  isSuccess?: boolean;\n  error: _IError;\n  isDataAvailable?: boolean;\n  data?: _ITimeSeriesData | null;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.isDataAvailable = false;\n    this.data = null;\n  }\n}\n\n// ================================ Value Store ================================\n// ------------ Set Value-Store ------------\nexport interface IAnedyaSetKeyReq{\n  namespace: {\n    scope: \"global\" | \"node\";\n    id?: string;\n  };\n  key: string;\n  value: string | number | boolean;\n  type: \"string\" | \"binary\" | \"float\" | \"boolean\";\n}\n\nexport class AnedyaSetKeyReq implements IAnedyaSetKeyReq {\n  constructor(\n    public namespace: {\n      scope: \"global\" | \"node\";\n      id?: string;\n    },\n    public key: string,\n    public value: string | number | boolean,\n    public type: \"string\" | \"binary\" | \"float\" | \"boolean\"\n  ) {\n    if (this.namespace.scope !== \"global\" && this.namespace.scope !== \"node\") {\n      throw new Error(\n        \"Invalid namespace scope. It should be either 'global' or 'node'.\"\n      );\n    }\n    if (\n      this.type !== \"string\" &&\n      this.type !== \"binary\" &&\n      this.type !== \"float\" &&\n      this.type !== \"boolean\"\n    ) {\n      throw new Error(\n        \"Invalid type value. It should be either 'string', 'binary', 'float', or 'boolean'.\"\n      );\n    }\n  }\n}\n\nexport interface IAnedyaSetKeyResp {\n  isSuccess: boolean;\n  error: _IError;\n}\n\nexport class AnedyaSetKeyResp implements IAnedyaSetKeyResp {\n  isSuccess: boolean;\n  error: _IError;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n  }\n}\n\n// ------------ Get Value-Store ------------\nexport interface IAnedyaGetKeyReq {\n  namespace: {\n    scope: \"global\" | \"node\";\n    id?: string;\n  };\n  key: string;\n}\n\nexport class AnedyaGetKeyReq implements IAnedyaGetKeyReq {\n  constructor(\n    public namespace: {\n      scope: \"global\" | \"node\";\n      id?: string;\n    },\n    public key: string\n  ) {\n    if (this.namespace.scope !== \"global\" && this.namespace.scope !== \"node\") {\n      throw new Error(\n        \"Invalid namespace scope. It should be either 'global' or 'node'.\"\n      );\n    }\n  }\n}\n\nexport interface IAnedyaGetKeyResp {\n  isSuccess: boolean;\n  error: _IError;\n  namespace: {\n    scope: string;\n    id: string;\n  };\n  key: string;\n  value: string | number | boolean;\n  type: string;\n  size: number;\n  modified: number;\n  created: number;\n}\n\nexport class AnedyaGetKeyResp implements IAnedyaGetKeyResp {\n  isSuccess: boolean;\n  error: _IError;\n  namespace: {\n    scope: string;\n    id: string;\n  };\n  key: string;\n  value: string | number | boolean | any;\n  type: string;\n  size: number;\n  modified: number;\n  created: number;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.namespace = { scope: \"\", id: \"\" };\n    this.key = \"\";\n    this.value = undefined;\n    this.type = \"\";\n    this.size = 0;\n    this.modified = 0;\n    this.created = 0;\n  }\n}\n\n// ------------ Delete Value-Store ------------\n\nexport interface IAnedyaDeleteKeyReq {\n  namespace: {\n    scope: \"global\" | \"node\";\n    id?: string;\n  };\n  key: string;\n}\nexport class AnedyaDeleteKeyReq implements IAnedyaDeleteKeyReq {\n  constructor(\n    public namespace: {\n      scope: \"global\" | \"node\";\n      id?: string;\n    },\n    public key: string\n  ) {\n    if (this.namespace.scope !== \"global\" && this.namespace.scope !== \"node\") {\n      throw new Error(\n        \"Invalid namespace scope. It should be either 'global' or 'node'.\"\n      );\n    }\n  }\n}\n\nexport interface IAnedyaDeleteKeyResp {\n  isSuccess: boolean;\n  error: _IError;\n}\n\nexport class AnedyaDeleteKeyResp implements IAnedyaDeleteKeyResp{\n  isSuccess: boolean;\n  error: _IError;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n  }\n}\n\n// ---------------- Value Store Scan ----------------\n\nexport interface IAnedyaScanKeysReq {\n  filter: {\n    namespace: {\n      scope: \"global\" | \"node\";\n      id?: string;\n    };\n  };\n  orderby: \"namespace\" | \"key\" | \"created\";\n  order: \"asc\" | \"desc\";\n  limit: number;\n  offset: number;\n}\n\nexport class AnedyaScanKeysReq\n  implements IAnedyaScanKeysReq\n{\n  constructor(\n    public filter: {\n      namespace: {\n        scope: \"global\" | \"node\";\n        id?: string;\n      };\n    },\n    public orderby: \"namespace\" | \"key\" | \"created\",\n    public order: \"asc\" | \"desc\",\n    public limit: number,\n    public offset: number\n  ) {\n    if (\n      this.filter.namespace.scope !== \"global\" &&\n      this.filter.namespace.scope !== \"node\"\n    ) {\n      throw new Error(\n        \"Invalid namespace scope. It should be either 'global' or 'node'.\"\n      );\n    }\n  }\n}\n\nexport interface IAnedyaScanKeysResp {\n  isSuccess: boolean;\n  error: _IError;\n  count: number;\n  totalCount: number;\n  data: any;\n  next: number;\n}\n\nexport class AnedyaScanKeysResp\n  implements IAnedyaScanKeysResp\n{\n  isSuccess: boolean;\n  error: _IError;\n  count: number;\n  totalCount: number;\n  data: any;\n  next: number;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.count = 0;\n    this.totalCount = 0;\n    this.data = undefined;\n    this.next = 0;\n  }\n}\n\n// ---------------- Device Status ----------------\n\nexport interface IAnedyaGetDeviceStatusResp {\n  isSuccess: boolean;\n  error: _IError;\n  data: any;\n}\n\nexport class AnedyaGetDeviceStatusResp\n  implements IAnedyaGetDeviceStatusResp\n{\n  isSuccess: boolean;\n  error: _IError;\n  data: any;\n  constructor() {\n    this.isSuccess = false;\n    this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.data = undefined;\n  }\n}\n\n// ---------------- Get Snapshot----------------\nexport interface IAnedyaGetSnapshotReq {\n  time: number;\n  variable: string;\n}\n\nexport class AnedyaGetSnapshotReq implements IAnedyaGetSnapshotReq {\n  constructor(\n    public time: number,\n    public variable: string,\n\n  ) {\n     // Validate timestamp\n    if (!Number.isFinite(time) || time <= 0) {\n      throw new Error(\"Invalid time: must be a positive number (UNIX timestamp).\");\n    }\n     const currentUnixTime = Math.floor(Date.now() / 1000);\n    if (time > currentUnixTime) {\n      throw new Error(\"Invalid time: timestamp cannot be in the future.\");\n    }\n\n    // Validate variable\n    if (!variable || typeof variable !== \"string\") {\n      throw new Error(\"Invalid variable: must be a non-empty string.\");\n    }\n  }\n}\n\n\nexport interface NodeVariableValue {\n  node: string;        // Node ID\n  value: number | string | boolean | Uint8Array; // Variable value\n  timestamp: number;   // Unix timestamp\n}\n\nexport type NodeVariableValues = NodeVariableValue[];\n\nexport interface IAnedyaGetSnapshotResp {\n  isSuccess: boolean;\n    error: _IError;\n  count: number;\n  data: NodeVariableValues;\n}\n\nexport class AnedyaGetSnapshotResp\n  implements IAnedyaGetSnapshotResp\n{\n  isSuccess: boolean;\n  error: _IError;\n  count: number;\n  data: NodeVariableValues;\n  constructor() {\n     this.error = { errorMessage: \"\", reasonCode: \"\" };\n    this.isSuccess = false;\n    this.count = 0;\n    this.data = []; \n  }\n}\n","import { IConfigHeaders } from \"./common\";\n\nexport const anedyaSignature = async (requestData: any, configHeaders: IConfigHeaders, currentTime: number): Promise<any> => {\n    try {\n      const encoder = new TextEncoder();\n      const bodyBytes = encoder.encode(JSON.stringify(requestData));\n  \n      // Create SHA-256 hash of the bodyBytes\n      const bodyHashBuffer = await crypto.subtle.digest(\"SHA-256\", bodyBytes);\n      const bodyHashBytes = new Uint8Array(bodyHashBuffer);\n  \n      const timeBytes = new Uint8Array(8);\n      new DataView(timeBytes.buffer).setBigUint64(0, BigInt(currentTime), false); // Big-endian\n  \n      // Combine [bodyHashBytes, timeBytes, signatureVersionBytes, tokenBytes]\n      const combinedBytes = new Uint8Array(\n        bodyHashBytes.length +\n          timeBytes.length +\n          configHeaders.signatureVersionBytes.length +\n          configHeaders.tokenBytes.length\n      );\n      combinedBytes.set(bodyHashBytes, 0);\n      combinedBytes.set(timeBytes, bodyHashBytes.length);\n      combinedBytes.set(\n        configHeaders.signatureVersionBytes,\n        bodyHashBytes.length + timeBytes.length\n      );\n      combinedBytes.set(\n        configHeaders.tokenBytes,\n        bodyHashBytes.length +\n          timeBytes.length +\n          configHeaders.signatureVersionBytes.length\n      );\n  \n      // Compute SHA-256 hash of combinedBytes\n      const combinedHashBuffer = await crypto.subtle.digest(\n        \"SHA-256\",\n        combinedBytes\n      );\n      const combinedHash = Array.from(new Uint8Array(combinedHashBuffer))\n        .map((b) => b.toString(16).padStart(2, \"0\"))\n        .join(\"\");\n      return combinedHash;\n    } catch (e) {\n      console.log(e);\n    }\n  }\n  ","/**\n *  Access Data from the Anedya platform side api.\n *\n * Provides functions to fetch historical and latest time-series data\n * from the Anedya platform API. These functions handle request signing,\n * header construction, error handling, and response normalization.\n */\n\nimport {\n  IAnedyaGetDataReq,\n  IAnedyaGetDataResp,\n  AnedyaGetDataResp,\n  IAnedyaGetLatestDataResp,\n  AnedyaGetLatestDataResp,\n} from \"../models\";\nimport { anedyaSignature } from \"../anedya_signature\";\nimport { IConfigHeaders, _ITimeSeriesData } from \"../common\";\n\n// ------------------------------ Get Data -----------------------------\n\n/**\n * Internal interface for the raw response structure of the `getData` API.\n * This matches the Anedya backend format before mapping into SDK response objects.\n */\n\ninterface _AnedyaGetDataResp {\n  success: boolean;\n  data: _ITimeSeriesData | null;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n  count: number;\n  startTime: number;\n  endTime: number;\n}\n\n/**\n * Fetch time-series data for a given node and variable from the Anedya platform.\n *\n * @param baseUrl - Base URL of the Anedya API endpoint.\n * @param configHeaders - Authentication + signature headers configuration.\n * @param nodes - Array of node IDs to fetch data for.\n * @param accessDataReq - Request parameters (variable name, time range, limit, order).\n * @returns Promise resolving to a structured response object.\n *\n * @example\n * ```ts\n * const req = new AnedyaGetDataReq(\"temperature\", from, to, 100);\n * const res = await getData(baseUrl, headers, [\"node123\"], req);\n * if (res.isSuccess && res.isDataAvailable) {\n *   console.log(res.data);\n * }\n * ```\n */\n\nexport const getData = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  accessDataReq: IAnedyaGetDataReq\n): Promise<any> => {\n  const url = `${baseUrl}/data/getData`;\n\n  // Request payload expected by Anedya backend\n  const requestData = {\n    nodes: nodes,\n    variable: accessDataReq.variable,\n    from: Math.floor(accessDataReq.from / 1000),\n    to: Math.floor(accessDataReq.to / 1000),\n    limit: accessDataReq.limit,\n    order: accessDataReq.order,\n  };\n\n  // Generate request signature for secure communication\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n\n  try {\n    // Required request headers for authentication & integrity\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n\n    // Perform the request\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    // Initialize SDK response object\n    let res: IAnedyaGetDataResp =\n      new AnedyaGetDataResp();\n    try {\n      // Parse raw backend response\n      let responseData: _AnedyaGetDataResp = await response.json();\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      res.isDataAvailable = false;\n      res.data = null;\n      // Map backend response into SDK response structure\n      if (responseData.success) {\n        let data: any = responseData.data;\n        if (\n          data == undefined ||\n          data == null ||\n          Object.keys(data).length === 0\n        ) {\n          res.isDataAvailable = false;\n        } else if (nodes.length === 1) {\n          data = data[nodes.toString()];\n          res.data = data;\n          res.isDataAvailable = true;\n        } else {\n          res.data = data;\n          res.isDataAvailable = true;\n        }\n      }\n      res.count = responseData.count;\n      res.startTime = responseData.startTime;\n      res.endTime = responseData.endTime;\n      return res;\n    } catch (error) {\n      // Handle malformed JSON or parsing issues\n      res.isSuccess = false;\n      res.error.reasonCode = response.status.toString();\n      res.error.errorMessage = response.statusText;\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during Get data request:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------ Get Latest Data -----------------------------\n\n/**\n * Internal interface for the raw response structure of the `latest` API.\n */\ninterface _AnedyaGetLatestDataResp {\n  success: boolean;\n  data: _ITimeSeriesData | null;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n  count: number;\n}\n\n/**\n * Fetch the most recent data point for a given node and variable.\n *\n * @param baseUrl - Base URL of the Anedya API endpoint.\n * @param configHeaders - Authentication + signature headers configuration.\n * @param nodes - Array of node IDs to fetch latest data for.\n * @param accessDataReq - Request parameters (contains variable identifier).\n * @returns Promise resolving to a structured response object.\n *\n * @example\n * ```ts\n * const req = { variable: \"temperature\" };\n * const res = await fetchLatestData(baseUrl, headers, [\"node123\"], req);\n * if (res.isSuccess && res.isDataAvailable) {\n *   console.log(\"Latest Data:\", res.data);\n * }\n * ```\n */\n\nexport const fetchLatestData = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  accessDataReq: any\n): Promise<any> => {\n  const url = `${baseUrl}/data/latest`;\n\n  // Request payload for latest data\n  const requestData = {\n    nodes: nodes,\n    variable: accessDataReq.variable,\n  };\n  const currentTime = Math.floor(Date.now() / 1000); // time in seconds\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    let res: IAnedyaGetLatestDataResp = new AnedyaGetLatestDataResp();\n    try {\n      const responseData: _AnedyaGetLatestDataResp =\n        await response.json();\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      res.isDataAvailable = false;\n      res.data = null;\n              // Map latest data into SDK response\n      if (responseData.success) {\n        let data: any = responseData.data;\n        if (\n          data == undefined ||\n          data == null ||\n          Object.keys(data).length === 0\n        ) {\n          res.isDataAvailable = false;\n        } else if (nodes.length === 1) {\n          data = data[nodes.toString()];\n          res.data = data;\n          res.isDataAvailable = true;\n        } else {\n          res.data = data;\n          res.isDataAvailable = true;\n        }\n      }\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.reasonCode = response.status.toString();\n      res.error.errorMessage = response.statusText;\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during get latest data request:\", error);\n    throw error;\n  }\n};\n","/*\n Access Data from the Anedya platform side api.\n*/\nimport {\n  AnedyaSetKeyReq,\n  IAnedyaDeleteKeyResp,\n  IAnedyaSetKeyResp,\n  IAnedyaGetKeyReq,\n  IAnedyaGetKeyResp,\n  IAnedyaDeleteKeyReq,\n  IAnedyaScanKeysReq,\n  IAnedyaScanKeysResp,\n  AnedyaDeleteKeyResp,\n  AnedyaScanKeysResp,\n  AnedyaSetKeyResp,\n  AnedyaGetKeyResp,\n} from \"../models\";\nimport { anedyaSignature } from \"../anedya_signature\";\nimport { IConfigHeaders } from \"../common\";\nimport { AnedyaError } from \"../errors\";\n\n// ------------------------------ Set Value-Store -----------------------------\ninterface _AnedyaSetKeyResp {\n  success: boolean;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n}\n\nexport const setKey = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  reqConfig: AnedyaSetKeyReq\n): Promise<any> => {\n  const url = `${baseUrl}/valuestore/setValue`;\n  let Id;\n  if (reqConfig.namespace.scope === \"node\") {\n    Id = nodes[0];\n  } else {\n    Id = reqConfig.namespace.id;\n  }\n\n  const requestData = {\n    namespace: {\n      scope: reqConfig.namespace.scope,\n      id: Id,\n    },\n    key: reqConfig.key,\n    value: reqConfig.value,\n    type: reqConfig.type,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n\n    let res: IAnedyaSetKeyResp = new AnedyaSetKeyResp();\n    try {\n      const responseData: _AnedyaSetKeyResp = await response.json();\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during set key: \", error);\n    throw error;\n  }\n};\n\n// ------------------------------ Get Value-Store -----------------------------\ninterface _AnedyaGetKeyResp {\n  success: boolean;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n  namespace: {\n    scope: string;\n    id: string;\n  };\n  key: string;\n  value: string | number | boolean;\n  type: string;\n  size: number;\n  modified: number;\n  created: number;\n}\n\nexport const getKey = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  reqConfig: IAnedyaGetKeyReq\n): Promise<any> => {\n  const url = `${baseUrl}/valuestore/getValue`;\n  let Id;\n  if (reqConfig.namespace.scope === \"node\") {\n    Id = nodes[0];\n  } else {\n    Id = reqConfig.namespace.id;\n  }\n\n  const requestData = {\n    namespace: {\n      scope: reqConfig.namespace.scope,\n      id: Id,\n    },\n    key: reqConfig.key,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    let res: IAnedyaGetKeyResp = new AnedyaGetKeyResp();\n\n    try {\n      const responseData: _AnedyaGetKeyResp = await response.json();\n      // console.log(responseData);\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      res.namespace = responseData.namespace;\n      res.key = responseData.key;\n      res.value = responseData.value;\n      res.type = responseData.type;\n      res.size = responseData.size;\n      res.modified = responseData.modified;\n      res.created = responseData.created;\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during get key request: \", error);\n    throw error;\n  }\n};\n\n// ------------------------------ Delete Value-Store -----------------------------\ninterface _AnedyaDeleteKeyResp {\n  success: boolean;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n}\n\nexport const deleteKey = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  reqConfig: IAnedyaDeleteKeyReq\n): Promise<any> => {\n  const url = `${baseUrl}/valuestore/delete`;\n  let Id;\n  if (reqConfig.namespace.scope === \"node\") {\n    Id = nodes[0];\n  } else {\n    Id = reqConfig.namespace.id;\n  }\n\n  const requestData = {\n    namespace: {\n      scope: reqConfig.namespace.scope,\n      id: Id,\n    },\n    key: reqConfig.key,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n\n    let res: IAnedyaDeleteKeyResp = new AnedyaDeleteKeyResp();\n    try {\n      const responseData: _AnedyaDeleteKeyResp = await response.json();\n      // console.log(responseData);\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during fetch operation:\", error);\n    throw error;\n  }\n};\n\n// ------------------------------  Scan Value-Store -----------------------------\ninterface _AnedyaScanKeysResp {\n  success: boolean;\n  errorcode: number;\n  error: string;\n  reasonCode: string;\n  count: number;\n  totalCount: number;\n  data: any[];\n  next: number;\n}\n\nexport const scanKeys = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  reqConfig: IAnedyaScanKeysReq\n): Promise<any> => {\n  const url = `${baseUrl}/valuestore/scan`;\n  let Id;\n  if (reqConfig.filter.namespace.scope === \"node\") {\n    Id = nodes[0];\n  } else {\n    Id = reqConfig.filter.namespace.id;\n  }\n\n  const requestData = {\n    filter: {\n      namespace: {\n        scope: reqConfig.filter.namespace.scope,\n        id: Id,\n      },\n    },\n    orderby: reqConfig.orderby,\n    order: reqConfig.order,\n    limit: reqConfig.limit,\n    offset: reqConfig.offset,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    let res: IAnedyaScanKeysResp =\n      new AnedyaScanKeysResp();\n    try {\n      const responseData: _AnedyaScanKeysResp =\n        await response.json();\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      res.count = responseData.count;\n      res.totalCount = responseData.totalCount;\n      res.data = responseData.data;\n      res.next = responseData.next;\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during scan vs operation: \", error);\n    throw error;\n  }\n};\n","import { Anedya } from \"../anedya\";\nimport { anedyaSignature } from \"../anedya_signature\";\nimport { IConfigHeaders } from \"../common\";\nimport {\n  IAnedyaGetDeviceStatusResp,\n  AnedyaGetDeviceStatusResp,\n} from \"../models\";\n\n// ------------------------ Device Status -------------------------\ninterface _AnedyaGetDeviceStatusResp {\n  success: boolean;\n  errcode: number;\n  error: string;\n  reasonCode: string;\n  data: any;\n}\n\nexport const getDeviceStatus = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  lastContactThreshold: number\n): Promise<any> => {\n  const url = `${baseUrl}/health/status`;\n\n  const requestData = {\n    nodes: nodes,\n    lastContactThreshold: lastContactThreshold,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    let res: IAnedyaGetDeviceStatusResp = new AnedyaGetDeviceStatusResp();\n    try {\n      const responseData: _AnedyaGetDeviceStatusResp =\n        await response.json();\n      // console.log(responseData);\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      if (!res.isSuccess) {\n        return res;\n      }\n      if (nodes.length === 1) {\n        res.data = responseData.data[nodes[0]];\n      } else {\n        res.data = responseData.data;\n      }\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during fetch operation:\", error);\n    throw error;\n  }\n};\n","import { Anedya } from \"../anedya\";\nimport { anedyaSignature } from \"../anedya_signature\";\nimport { IConfigHeaders } from \"../common\";\nimport {\n  IAnedyaGetSnapshotReq,\n  IAnedyaGetSnapshotResp,\n  AnedyaGetSnapshotResp,\n  NodeVariableValue,\n  NodeVariableValues,\n} from \"../models\";\n\n// ------------------------ Device Status -------------------------\ninterface _AnedyaGetSnapshotResp {\n  success: boolean;\n  error: string;\n  errorcode: number;\n  reasonCode: string;\n  count: number;\n  data: NodeVariableValues;\n}\n\nexport const getSnapshot = async (\n  baseUrl: string,\n  configHeaders: IConfigHeaders,\n  nodes: string[],\n  getSnapshotReq: IAnedyaGetSnapshotReq\n): Promise<any> => {\n  const url = `${baseUrl}/data/snapshot`;\n\n  const requestData = {\n    nodes: nodes,\n    time: getSnapshotReq?.time,\n    variable: getSnapshotReq?.variable,\n  };\n  const currentTime = Math.floor(Date.now() / 1000);\n  const combinedHash = await anedyaSignature(\n    requestData,\n    configHeaders,\n    currentTime\n  );\n  try {\n    const reqHeaders = {\n      Authorization: configHeaders.authorizationMode,\n      \"x-Anedya-SignatureVersion\": configHeaders.signatureVersion,\n      \"X-Anedya-Tokenid\": configHeaders.tokenId,\n      \"X-Anedya-Timestamp\": currentTime.toString(),\n      \"X-Anedya-Signature\": combinedHash,\n      \"Content-Type\": \"application/json\",\n    };\n    // console.log(reqHeaders);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      credentials: \"same-origin\",\n      headers: reqHeaders,\n      body: JSON.stringify(requestData),\n    });\n    let res: IAnedyaGetSnapshotResp = new AnedyaGetSnapshotResp();\n    try {\n      const responseData: _AnedyaGetSnapshotResp =\n        await response.json();\n      // console.log(responseData);\n      res.isSuccess = responseData.success;\n      res.error.errorMessage = responseData.error;\n      res.error.reasonCode = responseData.reasonCode;\n      if (!res.isSuccess) {\n        return res;\n      }\n\n      // If only one node was requested  filter array for that node\n      if (nodes.length === 1) {\n        res.data = responseData.data.filter(\n          (item: NodeVariableValue) => item.node === nodes[0]\n        );\n      } else {\n        // If multiple nodes  just return the full array\n        res.data = responseData.data;\n      }\n      res.count = responseData.count; // keep count in sync\n      return res;\n    } catch (error) {\n      res.isSuccess = false;\n      res.error.errorMessage = response.statusText;\n      res.error.reasonCode = response.status.toString();\n      return res;\n    }\n  } catch (error) {\n    console.error(\"Error during fetch operation:\", error);\n    throw error;\n  }\n};\n\n","/*\n * This module defines the NewNode class which represents a logical device node.\n *\n * A Node allows interaction with the Anedya platform, including:\n *  - Fetching historical and latest time-series data\n *  - Managing keys in the value store (set/get/delete/scan)\n *  - Checking device connectivity and status\n */\n\nimport { getData, fetchLatestData } from \"./services/accessData\";\nimport { setKey, getKey, deleteKey, scanKeys } from \"./services/valueStore\";\nimport { getDeviceStatus } from \"./services/deviceStatus\";\nimport {\n  IAnedyaGetDataReq,\n  AnedyaSetKeyReq,\n  IAnedyaGetKeyReq,\n  IAnedyaDeleteKeyReq,\n  IAnedyaScanKeysReq,\n  IAnedyaGetSnapshotReq,\n} from \"./models\";\nimport { NewClient } from \"./client\";\nimport { IConfigHeaders } from \"./common\";\nimport { getSnapshot } from \"./services/snapShot\";\n\n/**\n * INode defines the contract for interacting with a node in Anedya.\n * Each method corresponds to an available operation on a node.\n */\n\nexport interface INode {\n  /** Returns the unique identifier of this node */\n  getNodeId(): string;\n\n  /** Fetch historical time-series data for a given variable */\n  getData(accessDataReq: IAnedyaGetDataReq): Promise<any>;\n\n  /** Fetch the most recent data point for a given variable */\n  getLatestData(variableIdentifier: string): Promise<any>;\n\n  /** Store a key-value pair in the nodes value store */\n  setKey(reqConfig: AnedyaSetKeyReq): Promise<any>;\n\n  /** Retrieve a value from the nodes value store */\n  getKey(reqConfig: IAnedyaGetKeyReq): Promise<any>;\n\n  /** Delete a value from the nodes value store */\n  deleteKey(reqConfig: IAnedyaDeleteKeyReq): Promise<any>;\n\n  /** Scan through the nodes value store with filters */\n  scanKeys(reqConfig: IAnedyaScanKeysReq): Promise<any>;\n\n  /** Get device status (e.g., last contact timestamp) */\n  getDeviceStatus(lastContactThreshold: number): Promise<any>;\n\n  /**\n   * Returns value of a variable at a particular time for given set of nodes.\n   * Returns nearest datapoint submitted before specified time incase no datapoints found at the exact timestamp.\n   */\n  getSnapshot(reqConfig: IAnedyaGetSnapshotReq): Promise<any>;\n}\n\n/**\n * NewNode represents a Node in the Anedya platform and is a concrete implementation of INode.\n *\n *\n * A Node is the primary abstraction for interacting with data and value stores\n * belonging to a specific device. This class handles authentication, signing,\n * and structured request/response handling for Node operations.\n */\n\nexport class NewNode implements INode {\n  #nodeId: string; // Private node identifier\n  #baseUrl: string; // API base URL\n  #configHeaders: IConfigHeaders; // Authentication + signature headers\n\n  /**\n   * Construct a new Node instance.\n   *\n   * @param client - The initialized Anedya client with configuration details.\n   * @param nodeId - Unique identifier of the node to interact with.\n   */\n  constructor(client: NewClient, nodeId: string) {\n    const {\n      baseUrl,\n      tokenId,\n      tokenBytes,\n      signatureVersionBytes,\n      signatureVersion,\n      authorizationMode,\n    } = client;\n    this.#nodeId = nodeId; // Assign using #\n    this.#baseUrl = baseUrl;\n    this.#configHeaders = {\n      tokenId,\n      tokenBytes,\n      signatureVersion,\n      signatureVersionBytes,\n      authorizationMode,\n    };\n  }\n\n  /**\n   * Returns the Node ID.\n   *\n   * @returns {string} The node ID associated with this instance.\n   *\n   * @example\n   * ```ts\n   * console.log(node.getNodeId()); // \"device123\"\n   * ```\n   */\n  getNodeId(): string {\n    return this.#nodeId;\n  }\n\n  /**\n   * Fetches time-series data from the node within the given time range.\n   *\n   * @param {Object} accessDataReq - The request object for fetching data.\n   * @param {string} accessDataReq.variable - The variable identifier to fetch data for.\n   * @param {number} accessDataReq.from - The start timestamp (in ms) of the query range.\n   * @param {number} accessDataReq.to - The end timestamp (in ms) of the query range.\n   * @param {number} [accessDataReq.limit=10000] - The maximum number of data points to return.\n   * @param {\"asc\"|\"desc\"} [accessDataReq.order=\"desc\"] - The order of the data points to return.\n   * @returns {Promise<any>} A promise resolving to the response with data availability and payload.\n   *\n   * @example\n   * ```ts\n   * const req = new AnedyaGetDataReq(\"temperature\", Date.now() - 86400000, Date.now(), 100);\n   * const res = await node.getData(req);\n   * if (res.isSuccess && res.isDataAvailable) {\n   *   console.log(res.data);\n   * }\n   * ```\n   */\n  async getData(accessDataReq: IAnedyaGetDataReq): Promise<any> {\n    return await getData(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      accessDataReq\n    );\n  }\n\n  /**\n   * Fetches the latest data point from the node for the given variable.\n   *\n   * @param {string} variableIdentifier - The variable identifier to fetch the latest data point for.\n   * @returns {Promise<any>} A promise resolving to the response with data availability and payload.\n   *\n   * @example\n   * ```ts\n   * const res = await node.getLatestData(\"temperature\");\n   * if (res.isSuccess && res.isDataAvailable) {\n   *   console.log(\"Latest value:\", res.data);\n   * }\n   * ```\n   */\n  async getLatestData(variableIdentifier: string) {\n    const accessDataReq = {\n      variable: variableIdentifier,\n    };\n    return await fetchLatestData(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      accessDataReq\n    );\n  }\n\n  /**\n   * Sets a key/value pair in the Node's value store.\n   *\n   * This allows you to persist configuration or metadata at either the\n   * `GLOBAL` or `NODE` scope.\n   *\n   * - `AnedyaScope.GLOBAL`: The key/value is available across all nodes in the account.\n   * - `AnedyaScope.NODE`: The key/value is local to this specific node.\n   *\n   * Supported data types (via {@link AnedyaDataType}):\n   * - `STRING`  Stores string values\n   * - `BINARY`  Stores binary blobs\n   * - `FLOAT`  Stores numeric values with decimals\n   * - `BOOLEAN`  Stores true/false flags\n   *\n   * @param {AnedyaSetKeyRequestInterface} reqConfig - Request config including scope, key name, value, and type.\n   * @returns {Promise<any>} Response indicating success/failure of the operation.\n   *\n   * @example\n   * ```ts\n   * // Store a floating-point threshold value for a node\n   * const req = new AnedyaSetKeyReq(\n   *   { scope: AnedyaScope.NODE },   // Limit to this node\n   *   \"temperature\",                 // Key name\n   *   30,                            // Value\n   *   AnedyaDataType.FLOAT           // Data type\n   * );\n   *\n   * const res = await node.setKey(req);\n   * if (res.isSuccess) {\n   *   console.log(\"Key set successfully!\");\n   * }\n   * ```\n   */\n  async setKey(reqConfig: AnedyaSetKeyReq): Promise<any> {\n    return await setKey(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      reqConfig\n    );\n  }\n\n  /**\n   * Retrieves a previously stored value for a key from the Node's value store.\n   *\n   * Scope determines where the SDK looks for the key:\n   * - `AnedyaScope.GLOBAL`: Searches in the global store (shared across all nodes).\n   * - `AnedyaScope.NODE`: Searches in this nodes local store only.\n   *\n   * @param {AnedyaGetKeyReqInterface} reqConfig - Config with scope and key name to fetch.\n   * @returns {Promise<any>} Response containing the value if the key exists.\n   *\n   * @example\n   * ```ts\n   * // Fetch a temperature threshold key stored on this node\n   * const req = new AnedyaGetKeyReq(\n   *   { scope: AnedyaScope.NODE },\n   *   \"temperature\"\n   * );\n   *\n   * const res = await node.getKey(req);\n   * if (res.isSuccess && res.data) {\n   *   console.log(\"Key value:\", res.data);\n   * }\n   * ```\n   */\n  async getKey(reqConfig: IAnedyaGetKeyReq): Promise<any> {\n    return await getKey(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      reqConfig\n    );\n  }\n\n  /**\n   * Deletes a key/value pair from the Node's value store.\n   *\n   * Scope must match the scope in which the key was originally set:\n   * - `AnedyaScope.GLOBAL`: Removes the key from the global store.\n   * - `AnedyaScope.NODE`: Removes the key only from this nodes local store.\n   *\n   * @param {IAnedyaDeleteKeyReq} reqConfig - Config with scope and key name to delete.\n   * @returns {Promise<any>} Response indicating whether deletion succeeded.\n   *\n   * @example\n   * ```ts\n   * // Remove a temperature threshold key stored on this node\n   * const req = new AnedyaDeleteKeyReq(\n   *   { scope: AnedyaScope.NODE },\n   *   \"temperature\"\n   * );\n   *\n   * const res = await node.deleteKey(req);\n   * if (res.isSuccess) {\n   *   console.log(\"Key deleted successfully!\");\n   * }\n   * ```\n   */\n  async deleteKey(reqConfig: IAnedyaDeleteKeyReq): Promise<any> {\n    return await deleteKey(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      reqConfig\n    );\n  }\n\n  /**\n   * Scans available items in the valuestore in a given namespace, with support for pagination. Can return max 100 items per call.\n   *\n   *\n   * - Namespace must include a scope (`GLOBAL` or `NODE`).\n   * - Results can be ordered (`asc` or `desc`) and paginated using limit/offset.\n   *\n   * @param {AnedyaScanKeysReqInterface} reqConfig - Config including namespace, order, limit, and offset.\n   * @returns {Promise<any>} Response containing a list of matching keys.\n   *\n   * @example\n   * ```ts\n   * // Scan all available keys in the NODE namespace, return first 10 in ascending order\n   * const req = new AnedyaScanKeysReq(\n   *   { namespace: { scope: AnedyaScope.NODE } },\n   *   \"namespace\",\n   *   \"asc\",\n   *   10,\n   *   0\n   * );\n   *\n   * const res = await node.scanKeys(req);\n   * if (res.isSuccess && res.data) {\n   *   console.log(\"Keys scanned successfully!\", res.data);\n   * }\n   * ```\n   */\n  async scanKeys(reqConfig: IAnedyaScanKeysReq): Promise<any> {\n    return await scanKeys(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      reqConfig\n    );\n  }\n\n  /**\n   * Checks whether this node is currently online by evaluating its last heartbeat timestamp.\n   *\n   * The Anedya platform stores the last heartbeat time for each device.\n   * By passing `lastContactThreshold` (in seconds), you define how far back\n   * the system should look for a heartbeat to consider the device online.\n   *\n   * - If the last heartbeat occurred within the past `lastContactThreshold` seconds  `online: true`\n   * - Otherwise  `online: false`\n   *\n   * @param {number} lastContactThreshold - The number of past seconds in which the device must have\n   *   sent a heartbeat to be considered online. For example, if set to `60`, the node is only online\n   *   if its last heartbeat was within the last 60 seconds.\n   *\n   * @returns {Promise<any>} A promise resolving to the response object containing:\n   * - `online` (boolean): whether the node is online\n   * - `lastHeartbeat` (number): the last heartbeat timestamp (UNIX seconds)\n   *\n   * @example\n   * ```ts\n   * // Consider node online if it sent a heartbeat within the last 60 seconds\n   * const res = await node.getDeviceStatus(60);\n   * if (res.isSuccess && res.data) {\n   *   const status = res.data[node.getNodeId()];\n   *   console.log(\"Online:\", status.online);\n   *   console.log(\"Last heartbeat at:\", new Date(status.lastHeartbeat * 1000));\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Use a larger window (300 seconds) if your device reports less frequently\n   * const res = await node.getDeviceStatus(300);\n   * ```\n   */\n  async getDeviceStatus(lastContactThreshold: number): Promise<any> {\n    return await getDeviceStatus(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      lastContactThreshold\n    );\n  }\n\n  /**\n   * Retrieves the value of a variable for one or more nodes at a specific timestamp.\n   *\n   * The snapshot API returns the value of a variable at the requested time.\n   * - If a datapoint exists at exactly that timestamp, it is returned.\n   * - If no datapoint exists at that exact time, the nearest datapoint submitted\n   *   before the specified time will be returned instead.\n   *\n   * This is useful for reconstructing system state at a given point in time\n   * (e.g., \"What was the temperature at 10:00 AM for node X?\").\n   *\n   * @param {IAnedyaGetSnapshotReq} reqConfig - The snapshot request configuration.\n   * @param {number} reqConfig.time - The target timestamp (in UNIX seconds) to query.\n   * @param {string} reqConfig.variable - The variable identifier to fetch (e.g., `\"temperature\"`).\n   *\n   * @returns {Promise<any>} A promise resolving to the response object containing:\n   * - `node` (string): the node ID\n   * - `value` (number): the variable value at or before the given timestamp\n   * - `timestamp` (number): the timestamp (UNIX seconds) of the returned datapoint\n   *\n   * @example\n   * ```ts\n   * // Get temperature value for node at a specific timestamp\n   * const req = new AnedyaGetSnapshotReq(<timestamp>, <variableid>);\n   * const res = await node.getSnapshot(req);\n   * if (res.isSuccess && res.data.length > 0) {\n   *   const snapshot = res.data[0];\n   *   console.log(\"Temperature at\", new Date(snapshot.timestamp * 1000), \"was\", snapshot.value);\n   * }\n   * ```\n   *\n   * @example\n   * ```ts\n   * // Request snapshots for multiple nodes at the same time\n   * const req = new AnedyaGetSnapshotReq(1695084912, \"humidity\", [\"node123\", \"node456\"]);\n   * const res = await node.getSnapshot(req);\n   * res.data.forEach((entry) => {\n   *   console.log(entry.node, \"had humidity\", entry.value, \"at\", new Date(entry.timestamp * 1000));\n   * });\n   * ```\n   */\n  async getSnapshot(reqConfig: IAnedyaGetSnapshotReq): Promise<any> {\n    return await getSnapshot(\n      this.#baseUrl,\n      this.#configHeaders,\n      [this.#nodeId],\n      reqConfig\n    );\n  }\n}\n","/**\n * This file contains main entry class for the Anedya SDK.\n *\n * @packageDocumentation\n */\n\nimport { NewConfig } from \"./config\";\nimport { NewClient } from \"./client\";\nimport {NewNode} from \"./node\";\n\ninterface IAnedya {\n  NewConfig(tokenId: string, token: string): NewConfig;\n  NewClient(configData: NewConfig): NewClient;\n  NewNode(client: NewClient, nodeId: string): NewNode;\n}\n\nexport class Anedya implements IAnedya {\n\n  NewConfig(tokenId: string, token: string): NewConfig {\n    return new NewConfig(tokenId, token);\n  }\n\n  NewClient(configData: NewConfig): NewClient {\n    return new NewClient(configData);\n  }\n\n  NewNode(client: NewClient, nodeId: string): NewNode {\n    return new NewNode(client, nodeId);  \n  }\n}\n","export enum AnedyaScope {\n  GLOBAL = \"global\",\n  NODE = \"node\",\n}\n\nexport enum AnedyaDataType {\n  STRING = \"string\",\n  BINARY = \"binary\",\n  FLOAT = \"float\",\n  BOOLEAN = \"boolean\",\n}\n","export const AnedyaError = {\n  Success: -1,\n  Unknown: 0,\n  Failure: 1,\n  HttpRequestError: 3,\n  HttpRequestTimeout: 4,\n  keyNotFound: 5,\n} as const;\n\n\n// ------------------------------ Error Handling Enums -----------------------------\n\n/**\n * Common error codes returned by Anedya API responses.\n * Use these enums instead of hardcoding strings.\n */\nexport enum ErrorReason {\n   ACCESS_DENIED = \"auth::accessdenied\", \n  INVALID_SIGNATURE = \"INVALID_SIGNATURE\",\n  UNAUTHORIZED = \"UNAUTHORIZED\",\n  TOKEN_EXPIRED = \"TOKEN_EXPIRED\",\n  NODE_NOT_FOUND = \"NODE_NOT_FOUND\",\n  VARIABLE_NOT_FOUND = \"VARIABLE_NOT_FOUND\",\n  BAD_REQUEST = \"BAD_REQUEST\",\n  SERVER_ERROR = \"SERVER_ERROR\",\n  UNKNOWN_ERROR = \"UNKNOWN_ERROR\",\n}\n\n/**\n * HTTP error codes that might be returned by fetch().\n */\nexport enum HttpError {\n  BAD_REQUEST = 400,\n  UNAUTHORIZED = 401,\n  FORBIDDEN = 403,\n  NOT_FOUND = 404,\n  INTERNAL_SERVER_ERROR = 500,\n  BAD_GATEWAY = 502,\n  SERVICE_UNAVAILABLE = 503,\n  GATEWAY_TIMEOUT = 504,\n}","import { AnedyaError } from \"./errors\";\n\nexport function getAnedyaErrorMessage(code: number): string {\n  const reverseMap = Object.fromEntries(\n    Object.entries(AnedyaError).map(([k, v]) => [v, k])\n  );\n  return reverseMap[code] || \"UnknownErrorCode\";\n}"]}